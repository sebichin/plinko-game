<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Plinko: Ultimate Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #020617; 
            color: white;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            background: radial-gradient(circle at top, #1e293b 0%, #020617 70%);
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .score-pop {
            position: absolute;
            font-weight: 900;
            pointer-events: none;
            animation: floatUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 50;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -150%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -300%) scale(1); opacity: 0; }
        }

        #controls-area {
            flex-shrink: 0;
            background: #0f172a;
            border-top: 1px solid #1e293b;
            padding-bottom: env(safe-area-inset-bottom);
            z-index: 20;
        }

        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        /* Different color for size slider thumb to distinguish */
        #sizeSlider::-webkit-slider-thumb {
            background: #3b82f6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="flex-none px-4 py-3 flex justify-between items-center bg-slate-950 border-b border-slate-800 z-10">
        <div class="font-extrabold text-xl text-white tracking-tighter">
            <span class="text-pink-500">PLINKO</span><span class="text-slate-500">SIM</span>
        </div>
        <div class="text-right">
            <div class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Balance</div>
            <div class="text-xl font-mono font-bold text-white" id="balanceDisplay">$10,000</div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div id="game-container">
        <canvas id="world"></canvas>
        <div id="score-overlays" class="absolute inset-0 pointer-events-none"></div>
    </div>

    <!-- Controls -->
    <div id="controls-area" class="p-3 flex flex-col gap-3 shadow-2xl shadow-black">
        
        <!-- Settings Row -->
        <div class="flex gap-3">
            <div class="flex-1 bg-slate-900 rounded-lg p-2 border border-slate-800">
                <label class="text-[10px] text-slate-500 font-bold uppercase block mb-1">Rows</label>
                <select id="rowCount" class="w-full bg-transparent text-white text-sm font-bold focus:outline-none" onchange="restartGame()">
                    <option value="8">8 Rows (Low)</option>
                    <option value="12" selected>12 Rows (Med)</option>
                    <option value="16">16 Rows (High)</option>
                </select>
            </div>
            <div class="flex-1 bg-slate-900 rounded-lg p-2 border border-slate-800">
                <label class="text-[10px] text-slate-500 font-bold uppercase block mb-1">Bet Amount</label>
                <input type="number" id="betInput" value="100" class="w-full bg-transparent text-white font-mono text-sm focus:outline-none">
            </div>
        </div>

        <!-- Sliders Row -->
        <div class="flex gap-3">
            <!-- Auto Speed -->
            <div class="flex-1 bg-slate-900 rounded-lg px-3 py-2 border border-slate-800 flex flex-col justify-center">
                 <div class="flex justify-between items-center mb-2">
                     <span class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Auto Speed</span>
                     <span class="text-xs text-green-400 font-mono font-bold" id="speedDisplay">10/s</span>
                 </div>
                 <input type="range" id="speedSlider" min="1" max="20" value="10" class="w-full">
            </div>

            <!-- Ball Size -->
            <div class="flex-1 bg-slate-900 rounded-lg px-3 py-2 border border-slate-800 flex flex-col justify-center">
                 <div class="flex justify-between items-center mb-2">
                     <span class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Ball Size</span>
                     <span class="text-xs text-blue-400 font-mono font-bold" id="sizeDisplay">12%</span>
                 </div>
                 <input type="range" id="sizeSlider" min="5" max="45" value="12" class="w-full">
            </div>
        </div>

        <!-- Main Button -->
        <button id="dropBtn" class="w-full bg-[#00e701] hover:bg-[#00c601] active:bg-[#00a001] text-black font-black text-xl py-4 rounded-lg shadow-[0_0_20px_rgba(0,231,1,0.3)] uppercase tracking-widest transition-all select-none">
            Hold for Auto
        </button>
    </div>

    <script>
        // --- Sound System ---
        const SoundManager = {
            ctx: null,
            init: function() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playPegHit: function() {
                this.playTone(800 + (Math.random() * 400), 'triangle', 0.05, 0.05);
            },
            playScore: function(multiplier) {
                if (!this.ctx) return;
                if (multiplier < 1) {
                    this.playTone(150, 'sawtooth', 0.2, 0.08);
                } else if (multiplier >= 10) {
                    const now = this.ctx.currentTime;
                    [523, 659, 783, 1046].forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.08, now + i*0.05);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.05 + 0.3);
                        osc.connect(gain);
                        gain.connect(this.ctx.destination);
                        osc.start(now + i*0.05);
                        osc.stop(now + i*0.05 + 0.3);
                    });
                } else {
                    this.playTone(880, 'sine', 0.3, 0.1);
                }
            }
        };

        // --- Canvas Polyfill ---
        CanvasRenderingContext2D.prototype.roundRectSafe = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        }

        const MULTIPLIERS = {
            8:  [29, 4, 2, 0.3, 2, 4, 29],
            12: [170, 24, 8.1, 2, 1, 0.5, 1, 2, 8.1, 24, 170],
            16: [1000, 26, 9, 4, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 2, 4, 9, 26, 1000]
        };

        function getMultiplierColor(val) {
            if (val >= 100) return '#ef4444';
            if (val >= 10) return '#f97316';
            if (val >= 2) return '#eab308'; 
            return '#f59e0b';
        }

        let engine, render, runner;
        let width, height;
        let balance = 10000;
        let currentRows = 12;
        let gameActive = false;

        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body;

        function init() {
            const container = document.getElementById('game-container');
            const canvas = document.getElementById('world');

            if (render) {
                Render.stop(render);
                Runner.stop(runner);
                Engine.clear(engine);
                render.canvas.remove();
                render.canvas = null;
                render.context = null;
                render.textures = {};
            }

            width = container.clientWidth;
            height = container.clientHeight;
            if (height === 0) { setTimeout(init, 50); return; }

            engine = Engine.create();
            engine.world.gravity.y = 1.6; 
            engine.timing.timeScale = 0.7; 

            render = Render.create({
                element: container,
                canvas: canvas,
                engine: engine,
                options: {
                    width: width,
                    height: height,
                    wireframes: false,
                    background: 'transparent',
                    pixelRatio: window.devicePixelRatio || 1
                }
            });

            buildLevel();

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'collisionStart', handleCollision);
            Events.on(render, 'afterRender', drawOverlay);

            gameActive = true;
        }

        function buildLevel() {
            const rows = currentRows;
            const mults = MULTIPLIERS[rows];
            const numBuckets = mults.length;

            const paddingX = 24;
            const safeWidth = width - paddingX;
            let gap = safeWidth / numBuckets;
            if (gap > 50) gap = 50;

            const pyramidHeight = rows * gap;
            const startY = (height - pyramidHeight) / 2 - (gap * 1.0);
            
            const pegRadius = gap * 0.12;
            render.customData = { gap, rows, mults, startY, pegRadius, numBuckets };

            // Pegs
            for (let r = 2; r < rows; r++) {
                for (let c = 0; c <= r; c++) {
                    const x = width / 2 - (r * gap / 2) + (c * gap);
                    const y = startY + r * gap;
                    
                    const peg = Bodies.circle(x, y, pegRadius, {
                        isStatic: true,
                        label: 'peg',
                        render: { fillStyle: 'white' },
                        friction: 0,
                        restitution: 0.1 
                    });
                    Composite.add(engine.world, peg);
                }
            }

            // Sensors
            const lastRowY = startY + (rows - 1) * gap;
            const bucketY = lastRowY + (gap * 0.6); 
            const totalBucketWidth = numBuckets * gap;
            const startX = (width / 2) - (totalBucketWidth / 2) + (gap / 2);

            for (let i = 0; i < numBuckets; i++) {
                const x = startX + (i * gap);
                const sensor = Bodies.rectangle(x, bucketY, gap * 0.98, gap, {
                    isStatic: true,
                    isSensor: true,
                    label: 'sensor',
                    plugin: { val: mults[i] },
                    render: { visible: false }
                });
                Composite.add(engine.world, sensor);
            }
        }

        function drawOverlay() {
            const ctx = render.context;
            const data = render.customData;
            if (!data) return;

            const { gap, rows, mults, startY, numBuckets } = data;
            const lastRowY = startY + (rows - 1) * gap;
            const bucketY = lastRowY + (gap * 0.6); 

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const totalBucketWidth = numBuckets * gap;
            const startX = (width / 2) - (totalBucketWidth / 2) + (gap / 2);

            // Guides
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            
            for (let i = 0; i < mults.length; i++) {
                const x = startX + (i * gap);
                const val = mults[i];
                const color = getMultiplierColor(val);

                // Grid Line
                ctx.beginPath();
                ctx.moveTo(x - gap/2, lastRowY);
                ctx.lineTo(x - gap/2, bucketY + gap);
                ctx.stroke();

                // Box
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = color;
                const bw = gap * 0.96; 
                const bh = gap * 0.7;
                ctx.roundRectSafe(x - bw/2, bucketY - bh/2, bw, bh, 4);
                ctx.fill();

                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                let fontSize = Math.max(10, gap * 0.35);
                if (val >= 1000) fontSize *= 0.6;
                ctx.font = `800 ${fontSize}px Inter`;
                ctx.fillText(`${val}x`, x, bucketY + 1);
            }
        }

        function dropBall() {
            SoundManager.init();
            if (!gameActive) init();
            
            const betInput = document.getElementById('betInput');
            let bet = parseFloat(betInput.value);
            
            if (isNaN(bet) || bet <= 0) bet = 10;
            if (balance < bet) {
                const balEl = document.getElementById('balanceDisplay');
                balEl.style.color = 'red';
                setTimeout(() => balEl.style.color = 'white', 200);
                return; 
            }

            balance -= bet;
            updateUI();

            const data = render.customData;
            
            // --- SIZE LOGIC ---
            const sizeSlider = document.getElementById('sizeSlider');
            const sizePercent = parseInt(sizeSlider.value) / 100;
            const ballRadius = data.gap * sizePercent; 
            
            const jitter = (Math.random() * 2 - 1); 
            const spawnY = data.startY + (data.gap * 0.5);

            const ball = Bodies.circle(width / 2 + jitter, spawnY, ballRadius, {
                restitution: 0.1, 
                friction: 0.0, 
                frictionAir: 0.05, 
                density: 0.005, 
                label: 'ball',
                plugin: { bet: bet, active: true },
                render: { 
                    fillStyle: '#ff0055',
                    strokeStyle: '#ff88aa',
                    lineWidth: 2
                }
            });
            
            ball.collisionFilter.group = -1;
            Composite.add(engine.world, ball);
        }

        function handleCollision(e) {
            e.pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Find Ball
                let ball = bodyA.label === 'ball' ? bodyA : bodyB.label === 'ball' ? bodyB : null;
                if (!ball) return;

                // Check Sensor
                let sensor = bodyA.label === 'sensor' ? bodyA : bodyB.label === 'sensor' ? bodyB : null;
                if (sensor && ball.plugin.active) {
                    ball.plugin.active = false;
                    const mult = sensor.plugin.val;
                    const win = ball.plugin.bet * mult;
                    
                    SoundManager.playScore(mult);
                    balance += win;
                    updateUI();
                    spawnFloater(mult, win, ball.position.x, ball.position.y);
                    Composite.remove(engine.world, ball);
                    return;
                }

                // Check Peg (Chaos)
                let peg = bodyA.label === 'peg' ? bodyA : bodyB.label === 'peg' ? bodyB : null;
                if (peg) {
                    SoundManager.playPegHit();
                    if (ball.position.y < peg.position.y) {
                        const direction = Math.random() < 0.5 ? -1 : 1;
                        const forceMagnitude = 0.0002; 
                        Body.applyForce(ball, ball.position, { x: direction * forceMagnitude, y: 0 });
                    }
                }
            });
        }

        function updateUI() {
            document.getElementById('balanceDisplay').textContent = 
                '$' + balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
        }

        function spawnFloater(mult, winAmt, x, y) {
            const el = document.createElement('div');
            el.className = 'score-pop';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            
            const isWin = mult >= 1;
            const color = isWin ? '#4ade80' : '#94a3b8';
            const valColor = mult >= 10 ? '#f472b6' : 'white';
            
            el.innerHTML = `
                <div style="background: #1e293b; padding: 4px 8px; border-radius: 4px; border: 1px solid ${color}; display: flex; flex-col; align-items: center;">
                    <span style="color: ${valColor}; font-size: 12px;">${mult}x</span>
                    <span style="color: ${color}; font-size: 10px;">$${winAmt.toFixed(0)}</span>
                </div>
            `;

            document.getElementById('score-overlays').appendChild(el);
            setTimeout(() => el.remove(), 1200);
        }

        function restartGame() {
            currentRows = parseInt(document.getElementById('rowCount').value);
            init();
        }

        // --- Sliders & Auto Logic ---
        const btn = document.getElementById('dropBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeDisplay = document.getElementById('sizeDisplay');
        
        let autoInterval = null;

        function startAuto() {
            if (autoInterval) return;
            dropBall();
            btn.classList.add('scale-95', 'brightness-110');
            const rate = parseInt(speedSlider.value);
            autoInterval = setInterval(() => {
                if(balance < parseFloat(document.getElementById('betInput').value)) {
                    stopAuto();
                    return;
                }
                dropBall();
            }, 1000 / rate);
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
            }
            btn.classList.remove('scale-95', 'brightness-110');
        }

        // Sliders
        speedSlider.addEventListener('input', (e) => {
            const rate = e.target.value;
            speedDisplay.textContent = `${rate}/s`;
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = setInterval(() => {
                    if(balance < parseFloat(document.getElementById('betInput').value)) {
                        stopAuto();
                        return;
                    }
                    dropBall();
                }, 1000 / rate);
            }
        });

        sizeSlider.addEventListener('input', (e) => {
            sizeDisplay.textContent = `${e.target.value}%`;
        });

        // Input Events
        btn.addEventListener('mousedown', startAuto);
        window.addEventListener('mouseup', stopAuto);
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startAuto();
        }, {passive: false});
        window.addEventListener('touchend', stopAuto);

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(init, 200);
        });

        window.onload = init;

    </script>
</body>
</html>


