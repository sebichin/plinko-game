<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Plinko: Ultimate Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="physics-engine.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #020617; 
            color: white;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            background: radial-gradient(circle at top, #1e293b 0%, #020617 70%);
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .score-pop {
            position: absolute;
            font-weight: 900;
            pointer-events: none;
            animation: floatUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 50;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -150%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -300%) scale(1); opacity: 0; }
        }

        #controls-area {
            flex-shrink: 0;
            background: #0f172a;
            border-top: 1px solid #1e293b;
            padding-bottom: env(safe-area-inset-bottom);
            z-index: 20;
        }

        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        /* Different color for size slider thumb to distinguish */
        #sizeSlider::-webkit-slider-thumb {
            background: #3b82f6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="flex-none px-4 py-3 flex justify-between items-center bg-slate-950 border-b border-slate-800 z-10">
        <div class="font-extrabold text-xl text-white tracking-tighter">
            <span class="text-pink-500">PLINKO</span><span class="text-slate-500">SIM</span>
        </div>
        <div class="text-right">
            <div class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Balance</div>
            <div class="text-xl font-mono font-bold text-white" id="balanceDisplay">$10,000</div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div id="game-container">
        <canvas id="world"></canvas>
        <div id="score-overlays" class="absolute inset-0 pointer-events-none"></div>
    </div>

    <!-- Controls -->
    <div id="controls-area" class="p-3 flex flex-col gap-3 shadow-2xl shadow-black">
        
        <!-- Settings Row -->
        <div class="flex gap-3">
            <div class="flex-1 bg-slate-900 rounded-lg p-2 border border-slate-800">
                <label class="text-[10px] text-slate-500 font-bold uppercase block mb-1">Rows</label>
                <select id="rowCount" class="w-full bg-transparent text-white text-sm font-bold focus:outline-none" onchange="restartGame()">
                    <option value="8">8 Rows (Low)</option>
                    <option value="12" selected>12 Rows (Med)</option>
                    <option value="16">16 Rows (High)</option>
                </select>
            </div>
            <div class="flex-1 bg-slate-900 rounded-lg p-2 border border-slate-800">
                <label class="text-[10px] text-slate-500 font-bold uppercase block mb-1">Bet Amount</label>
                <div class="flex gap-2 items-center">
                    <input type="number" id="betInput" value="100" class="flex-1 bg-transparent text-white font-mono text-sm focus:outline-none">
                    <button id="maxBtn" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 text-white text-xs font-bold rounded transition-colors">MAX</button>
                </div>
            </div>
        </div>

        <!-- Sliders Row -->
        <div class="flex gap-3">
            <!-- Auto Speed -->
            <div class="flex-1 bg-slate-900 rounded-lg px-3 py-2 border border-slate-800 flex flex-col justify-center">
                 <div class="flex justify-between items-center mb-2">
                     <span class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Auto Speed</span>
                     <span class="text-xs text-green-400 font-mono font-bold" id="speedDisplay">10/s</span>
                 </div>
                 <input type="range" id="speedSlider" min="1" max="20" value="10" class="w-full">
            </div>

            <!-- Ball Size -->
            <div class="flex-1 bg-slate-900 rounded-lg px-3 py-2 border border-slate-800 flex flex-col justify-center">
                 <div class="flex justify-between items-center mb-2">
                     <span class="text-[10px] text-slate-500 font-bold uppercase tracking-wider">Ball Size</span>
                     <span class="text-xs text-blue-400 font-mono font-bold" id="sizeDisplay">35%</span>
                 </div>
                 <input type="range" id="sizeSlider" min="5" max="45" value="35" class="w-full">
            </div>
        </div>

        <!-- Main Button -->
        <button id="dropBtn" class="w-full bg-[#00e701] hover:bg-[#00c601] active:bg-[#00a001] text-black font-black text-xl py-4 rounded-lg shadow-[0_0_20px_rgba(0,231,1,0.3)] uppercase tracking-widest transition-all select-none">
            Hold for Auto
        </button>
    </div>

    <script>
        // --- Sound System ---
        const SoundManager = {
            ctx: null,
            init: function() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playPegHit: function() {
                this.playTone(800 + (Math.random() * 400), 'triangle', 0.05, 0.05);
            },
            playScore: function(multiplier) {
                if (!this.ctx) return;
                if (multiplier < 1) {
                    this.playTone(150, 'sawtooth', 0.2, 0.08);
                } else if (multiplier >= 10) {
                    const now = this.ctx.currentTime;
                    [523, 659, 783, 1046].forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.08, now + i*0.05);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.05 + 0.3);
                        osc.connect(gain);
                        gain.connect(this.ctx.destination);
                        osc.start(now + i*0.05);
                        osc.stop(now + i*0.05 + 0.3);
                    });
                } else {
                    this.playTone(880, 'sine', 0.3, 0.1);
                }
            }
        };

        // --- Canvas Polyfill ---
        CanvasRenderingContext2D.prototype.roundRectSafe = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        }

        const MULTIPLIERS = {
            8:  [29, 4, 2, 0.3, 2, 4, 29],
            12: [170, 24, 8.1, 2, 1, 0.5, 1, 2, 8.1, 24, 170],
            16: [1000, 26, 9, 4, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 2, 4, 9, 26, 1000]
        };

        function getMultiplierColor(val) {
            if (val >= 100) return '#ef4444';
            if (val >= 10) return '#f97316';
            if (val >= 2) return '#eab308'; 
            return '#f59e0b';
        }

        let engine, canvas, ctx;
        let width, height;
        let balance = 10000;
        let currentRows = 12;
        let gameActive = false;
        let animationFrameId = null;
        let customData = null;

        function init() {
            const container = document.getElementById('game-container');
            canvas = document.getElementById('world');

            if (engine) {
                // Clean up previous engine
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                engine.clear();
            }

            width = container.clientWidth;
            height = container.clientHeight;
            if (height === 0) { setTimeout(init, 50); return; }

            // Set canvas size
            canvas.width = width * (window.devicePixelRatio || 1);
            canvas.height = height * (window.devicePixelRatio || 1);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);

            // Create custom physics engine with realistic gravity
            // gravity.y = 980 pixels/s² approximates Earth gravity (9.8 m/s²) at ~100 pixels/meter scale
            engine = new PhysicsEngine({ gravity: 980 });

            buildLevel();

            // Register collision callback
            engine.onCollision(handleCollision);

            // Start render loop
            startRenderLoop();

            gameActive = true;
        }

        function buildLevel() {
            const rows = currentRows;
            const mults = MULTIPLIERS[rows];
            const numBuckets = mults.length;

            // Smart gap: constrain by width AND height to fit all screen sizes
            const paddingX = 48; // 24px each side
            const paddingY = 40;
            const safeWidth = width - paddingX;
            const safeHeight = height - paddingY;
            const gapByWidth = safeWidth / numBuckets;
            const gapByHeight = safeHeight / (rows + 2.8);
            const minGap = 25, maxGap = 65;
            let gap = Math.max(minGap, Math.min(maxGap, gapByWidth, gapByHeight));

            const totalGameHeight = (rows + 2.8) * gap;
            const startY = (height - totalGameHeight) / 2;
            const pegRadius = gap * 0.12;
            customData = { gap, rows, mults, startY, pegRadius, numBuckets };

            // Pegs
            for (let r = 2; r < rows; r++) {
                for (let c = 0; c <= r; c++) {
                    const x = width / 2 - (r * gap / 2) + (c * gap);
                    const y = startY + r * gap;
                    
                    const peg = new RigidBody('circle', x, y, {
                        radius: pegRadius,
                        isStatic: true,
                        label: 'peg',
                        render: { fillStyle: 'white' },
                        // Low friction for plastic surface with metal ball (coefficient ~0.08-0.12)
                        friction: 0.1,
                        // Higher restitution for hard plastic pegs with metal ball
                        restitution: 0.7,
                        // Low static friction for smooth metal-on-plastic contact
                        frictionStatic: 0.05
                    });
                    engine.addBody(peg);
                }
            }

            // Sensors
            const lastRowY = startY + (rows - 1) * gap;
            const bucketY = lastRowY + (gap * 0.6); 
            const totalBucketWidth = numBuckets * gap;
            const startX = (width / 2) - (totalBucketWidth / 2) + (gap / 2);

            for (let i = 0; i < numBuckets; i++) {
                const x = startX + (i * gap);
                const sensor = new RigidBody('rectangle', x, bucketY, {
                    width: gap * 0.98,
                    height: gap,
                    isStatic: true,
                    isSensor: true,
                    label: 'sensor',
                    plugin: { val: mults[i] },
                    render: { visible: false }
                });
                engine.addBody(sensor);
            }
        }

        let lastFrameTime = performance.now();
        let interpolationAlpha = 0;

        function startRenderLoop() {
            function loop(currentTime) {
                const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
                lastFrameTime = currentTime;

                // Update physics with fixed timestep
                interpolationAlpha = engine.update(deltaTime);

                // Render
                render();

                animationFrameId = requestAnimationFrame(loop);
            }

            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(loop);
        }

        function render() {
            if (!ctx || !customData) return;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw overlay (buckets and guides)
            drawOverlay();

            // Draw all bodies
            engine.bodies.forEach(body => {
                if (body.render && body.render.visible === false) return;

                // Use interpolated position for smooth rendering
                const pos = engine.getInterpolatedPosition(body, interpolationAlpha);
                
                ctx.save();
                ctx.translate(pos.x, pos.y);

                if (body.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, body.radius, 0, Math.PI * 2);
                    ctx.fillStyle = body.render.fillStyle || '#ffffff';
                    ctx.fill();
                    
                    if (body.render.strokeStyle) {
                        ctx.strokeStyle = body.render.strokeStyle;
                        ctx.lineWidth = body.render.lineWidth || 1;
                        ctx.stroke();
                    }
                } else if (body.shape === 'rectangle') {
                    const halfW = body.width / 2;
                    const halfH = body.height / 2;
                    
                    ctx.fillStyle = body.render.fillStyle || '#ffffff';
                    ctx.fillRect(-halfW, -halfH, body.width, body.height);
                    
                    if (body.render.strokeStyle) {
                        ctx.strokeStyle = body.render.strokeStyle;
                        ctx.lineWidth = body.render.lineWidth || 1;
                        ctx.strokeRect(-halfW, -halfH, body.width, body.height);
                    }
                }

                ctx.restore();
            });
        }

        function drawOverlay() {
            const data = customData;
            if (!data) return;

            const { gap, rows, mults, startY, numBuckets } = data;
            const lastRowY = startY + (rows - 1) * gap;
            const bucketY = lastRowY + (gap * 0.6); 

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const totalBucketWidth = numBuckets * gap;
            const startX = (width / 2) - (totalBucketWidth / 2) + (gap / 2);

            // Guides
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            
            for (let i = 0; i < mults.length; i++) {
                const x = startX + (i * gap);
                const val = mults[i];
                const color = getMultiplierColor(val);

                // Grid Line
                ctx.beginPath();
                ctx.moveTo(x - gap/2, lastRowY);
                ctx.lineTo(x - gap/2, bucketY + gap);
                ctx.stroke();

                // Box
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = color;
                const bw = gap * 0.96; 
                const bh = gap * 0.7;
                ctx.roundRectSafe(x - bw/2, bucketY - bh/2, bw, bh, 4);
                ctx.fill();

                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                let fontSize = Math.max(10, gap * 0.35);
                if (val >= 1000) fontSize *= 0.6;
                ctx.font = `800 ${fontSize}px Inter`;
                ctx.fillText(`${val}x`, x, bucketY + 1);
            }
        }

        function dropBall() {
            SoundManager.init();
            if (!gameActive) init();
            
            const betInput = document.getElementById('betInput');
            let bet = parseFloat(betInput.value);
            
            if (isNaN(bet) || bet <= 0) bet = 10;
            if (balance < bet) {
                const balEl = document.getElementById('balanceDisplay');
                balEl.style.color = 'red';
                setTimeout(() => balEl.style.color = 'white', 200);
                return; 
            }

            balance -= bet;
            updateUI();

            const data = customData;
            
            // --- SIZE LOGIC ---
            const sizeSlider = document.getElementById('sizeSlider');
            const sizePercent = parseInt(sizeSlider.value) / 100;
            const ballRadius = data.gap * sizePercent; 
            
            // Subtle initial position variance for natural distribution
            const jitter = (Math.random() * 1 - 0.5); 
            // Spawn ball higher to give more visible drop before hitting pegs
            // Metal balls need more initial drop distance for realistic behavior
            const spawnY = data.startY + (data.gap * 1.2);

            const ball = new RigidBody('circle', width / 2 + jitter, spawnY, {
                radius: ballRadius,
                // Metal balls have low restitution (steel on hard plastic: ~0.3-0.5)
                // This creates less bouncy, more realistic metal ball behavior
                restitution: 0.35, 
                // Very low friction for metal on plastic surface (coefficient ~0.05-0.10)
                friction: 0.08, 
                // Minimal air resistance for dense metal ball
                frictionAir: 0.005, 
                // Metal density: Steel ball density (7.85 g/cm³)
                // Using 0.008 for realistic heavy metal ball behavior
                density: 0.008, 
                label: 'ball',
                plugin: { bet: bet, active: true },
                render: { 
                    fillStyle: '#ff0055',
                    strokeStyle: '#ff88aa',
                    lineWidth: 2
                },
                collisionFilter: { group: -1 }
            });
            
            // Apply subtle initial velocity for realistic drop simulation
            const initialVelocityX = (Math.random() - 0.5) * 0.1;
            ball.velocity = new Vec2(initialVelocityX, 0);
            
            engine.addBody(ball);
        }

        function handleCollision(event) {
            const { bodyA, bodyB } = event;
            
            // Find Ball
            let ball = bodyA.label === 'ball' ? bodyA : bodyB.label === 'ball' ? bodyB : null;
            if (!ball) return;

            // Check Sensor
            let sensor = bodyA.label === 'sensor' ? bodyA : bodyB.label === 'sensor' ? bodyB : null;
            if (sensor && ball.plugin.active) {
                ball.plugin.active = false;
                const mult = sensor.plugin.val;
                const win = ball.plugin.bet * mult;
                
                SoundManager.playScore(mult);
                balance += win;
                updateUI();
                spawnFloater(mult, win, ball.position.x, ball.position.y);
                engine.removeBody(ball);
                return;
            }

            // Check Peg (Natural Physics Interaction)
            let peg = bodyA.label === 'peg' ? bodyA : bodyB.label === 'peg' ? bodyB : null;
            if (peg) {
                // Calculate relative velocity to distinguish impact from resting contact
                // This prevents rapid audio playback during continuous contact (60 sounds/sec)
                const { collision } = event;
                const velA = bodyA.getPointVelocity(collision.contactPoint);
                const velB = bodyB.getPointVelocity(collision.contactPoint);
                const relativeVel = {
                    x: velB.x - velA.x,
                    y: velB.y - velA.y
                };
                
                // Calculate velocity magnitude along collision normal
                // velAlongNormal represents the "impact speed" perpendicular to collision surface
                const velAlongNormal = Math.abs(
                    relativeVel.x * collision.normal.x + 
                    relativeVel.y * collision.normal.y
                );
                
                // Only play sound if impact velocity exceeds threshold
                // Threshold of 50 px/s filters out resting contact oscillations (~16 px/s from gravity)
                // This allows real bounces while silencing continuous contact
                const IMPACT_THRESHOLD = 50; // pixels per second
                if (velAlongNormal > IMPACT_THRESHOLD) {
                    SoundManager.playPegHit();
                }
                
                // Let natural physics handle deflection through restitution and friction
                // No artificial force needed - realistic bounce creates proper randomness
            }
        }

        function updateUI() {
            document.getElementById('balanceDisplay').textContent = 
                '$' + balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
        }

        function spawnFloater(mult, winAmt, x, y) {
            const el = document.createElement('div');
            el.className = 'score-pop';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            
            const isWin = mult >= 1;
            const color = isWin ? '#4ade80' : '#94a3b8';
            const valColor = mult >= 10 ? '#f472b6' : 'white';
            
            el.innerHTML = `
                <div style="background: #1e293b; padding: 4px 8px; border-radius: 4px; border: 1px solid ${color}; display: flex; flex-col; align-items: center;">
                    <span style="color: ${valColor}; font-size: 12px;">${mult}x</span>
                    <span style="color: ${color}; font-size: 10px;">$${winAmt.toFixed(0)}</span>
                </div>
            `;

            document.getElementById('score-overlays').appendChild(el);
            setTimeout(() => el.remove(), 1200);
        }

        function restartGame() {
            currentRows = parseInt(document.getElementById('rowCount').value);
            init();
        }

        // --- Sliders & Auto Logic ---
        const btn = document.getElementById('dropBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeDisplay = document.getElementById('sizeDisplay');
        
        let autoInterval = null;

        function startAuto() {
            if (autoInterval) return;
            dropBall();
            btn.classList.add('scale-95', 'brightness-110');
            const rate = parseInt(speedSlider.value);
            autoInterval = setInterval(() => {
                if(balance < parseFloat(document.getElementById('betInput').value)) {
                    stopAuto();
                    return;
                }
                dropBall();
            }, 1000 / rate);
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
            }
            btn.classList.remove('scale-95', 'brightness-110');
        }

        // Sliders
        speedSlider.addEventListener('input', (e) => {
            const rate = e.target.value;
            speedDisplay.textContent = `${rate}/s`;
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = setInterval(() => {
                    if(balance < parseFloat(document.getElementById('betInput').value)) {
                        stopAuto();
                        return;
                    }
                    dropBall();
                }, 1000 / rate);
            }
        });

        sizeSlider.addEventListener('input', (e) => {
            sizeDisplay.textContent = `${e.target.value}%`;
        });

        // Max button functionality
        document.getElementById('maxBtn').addEventListener('click', () => {
            const betInput = document.getElementById('betInput');
            betInput.value = Math.floor(balance);
        });

        // Input Events
        btn.addEventListener('mousedown', startAuto);
        window.addEventListener('mouseup', stopAuto);
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startAuto();
        }, {passive: false});
        window.addEventListener('touchend', stopAuto);

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(init, 200);
        });

        window.onload = init;

    </script>
</body>
</html>


